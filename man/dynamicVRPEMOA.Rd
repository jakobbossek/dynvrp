% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/emoa.R
\name{dynamicVRPEMOA}
\alias{dynamicVRPEMOA}
\title{Evolutionary Multi-Objective Algorithm for dynamic routing of a vehicle.}
\usage{
dynamicVRPEMOA(fitness.fun, instance, time.resolution = 100L,
  n.timeslots = NULL, n.vehicles = 1L,
  decision.fun = dynvrp::decideRandom, do.pause = FALSE, p.swap = 1,
  init.keep = TRUE, local.search.method = NULL, local.search.gens = 100L,
  init.distribution = "binomial", stop.conds = list(ecr::stopOnIters(100L)),
  mu = 50L, local.search.args = list(), lambda = mu, ...)
}
\arguments{
\item{fitness.fun}{[\code{function(ind, instance, ...)}]\cr
Fitness function depends on individuals (see docs for initIndividual),
the problem instnace of type \code{\link[salesperson]{Network}} and
optional further parameter (not used at the moment).}

\item{instance}{[\code{\link[salesperson]{Network}}]\cr
Network object with exactly two depots and optional release dates.}

\item{time.resolution}{[\code{numeric(1)}]\cr
Width of time windows.}

\item{n.timeslots}{[\code{integer(1)} | \code{NULL}]\cr
Number of time steps.
If \code{NULL} (default), the value is computed via (max. request time
of dynamic customers of \code{instance} / time.resolution.}

\item{n.vehicles}{[\code{integer(1)}]\cr
The number of vehicles.
Default is 1.}

\item{decision.fun}{[\code{function(fitness, ...)}]\cr
Function used to make decision after each time slot.
May be used for interactive decision or decision maker simulation (e.g.,
always decide for lexicographic optimum regarding one of the objective functions).
Default is \code{decideRandom}, i.e., random choice of solution.}

\item{do.pause}{[\code{logical(1)}]\cr
Pause execution after each time slot?
Default is \code{FALSE}.}

\item{p.swap}{[\code{numeric(1)}]\cr
Probability for swap mutation.
Default is 1.}

\item{init.keep}{[\code{logical(1)}]\cr
Should individuals in eras \eqn{> 1} carry over information from last population?
Default is \code{TRUE}.}

\item{local.search.method}{[\code{character(1)}]\cr
Local search algorithm. Default is \code{NULL}, i.e., no
local search at all.}

\item{local.search.gens}{[\code{numeric}]\cr
Generations where local search should be applied.}

\item{init.distribution}{[\code{character(1)}]\cr
How shall available dynamic customers be sampled?
Option \dQuote{binomial}: each dynamic available customer is active with probability \eqn{0.5}
independently.
Option \dQuote{uniform}: if there are \eqn{n_d} available dynamic customers,
we have \eqn{P(X = i) = \frac{1}{n_d}} for \eqn{i \in \{1, \ldots, n_d\}}. In a second step
\eqn{i} positions are sampled at random.}

\item{stop.conds}{[\code{list[ecr_terminator]}]\cr
List of stopping conditions for each internal EMOA run.
Default is to stop after 100 generations.}

\item{mu}{[\code{integer(1)}]\cr
Population size.
Defaults to 50.}

\item{lambda}{[\code{integer(1)}]\cr
Number of offspring.
Default is \code{mu}.}

\item{...}{[any]\cr
Not used at the moment.}
}
\value{
[list] List of \code{ecr_result} objects.
}
